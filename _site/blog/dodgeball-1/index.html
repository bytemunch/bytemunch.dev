<!DOCTYPE html>
<html lang="en" data-theme="light">
    <script>
        document.querySelector("html").setAttribute("data-theme", localStorage.getItem("theme") || "light");
    </script>
    <head>
        <link
        rel="stylesheet" href="/assets/css/styles.css"> <!-- eleventy-plugin-metagen --><meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>dodgeball login - bytemunch.dev</title>
	<meta name="author" content="Sam Edelsten">
	<meta name="title" content="dodgeball login - bytemunch.dev">
	<meta name="description" content="auth is hard">
	<meta name="generator" content="eleventy">
	<!-- Open Graph -->
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://bytemunch.dev/blog/dodgeball-1/">
	<meta property="og:locale" content="en_US">
	<meta property="og:title" content="dodgeball login - bytemunch.dev">
	<meta property="og:description" content="auth is hard">
	<meta property="og:image" content="/projects/dodgeball/img/thumb.png">
	<meta property="og:image:alt" content="a dodgeball with an explosion of shrapnel behind it
">
	<!-- Twitter -->
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:site" content="@bytemunch">
	<meta name="twitter:creator" content="@bytemunch">
	<meta name="twitter:url" content="https://bytemunch.dev/blog/dodgeball-1/">
	<meta name="twitter:title" content="dodgeball login - bytemunch.dev">
	<meta name="twitter:description" content="auth is hard">
	<meta name="twitter:image" content="/projects/dodgeball/img/thumb.png">
	<meta name="twitter:image:alt" content="a dodgeball with an explosion of shrapnel behind it
">
	<link rel="canonical" href="https://bytemunch.dev/blog/dodgeball-1/">
    </head>
    <body>
        <div id="main">
            <div class="title">
                <h1>
                    <a href="/">bytemunch<span class="title-secondary">dot</span>dev</a><a href="/blog" class="title-location">
                            <span class="title-secondary">slash</span>blog</a></h1>
                <p
                    id="theme-switch"
                    href="javascript:void(0)"
                    onclick=" let theme = localStorage.getItem('theme') || 'light'; document.querySelector('#theme-switch').textContent =
                        theme; theme = theme == 'light' ? 'dark' : 'light'; localStorage.setItem('theme',theme);
                        document.querySelector('html').setAttribute('data-theme',theme); ">
                    theme toggle</p>
                <script>
                    let theme = localStorage.getItem('theme') || 'light';
                    document.querySelector('#theme-switch').textContent = theme == 'light'
                        ? 'dark'
                        : 'light';
                </script>
            </div>
            


<nav>
    <ol class='post-paginate'>
        <li>
            Previous:
            
                <a href="/blog/dodgeball-0/">dodgeball returns</a>
            
        </li>
        <li>
            Next:
            
                <a href="/blog/site-update-0/">website refresh</a>
            
        </li>
    </ol>
</nav>
<div id="post-header">
    <h1>dodgeball login</h1>
    <p>auth is hard</p>
    <p class="date">10/05/2023</p>
</div>
<div id="post">
    <h2>Actual Login</h2>
<p>Okay, so I can get an OAuth2 access token. How do I use that to view and edit firebase data?
I know in future I'm going to need some robust access rules, but for now I'll just allow all permissions if the user is logged in.</p>
<p>I'll need to create a game account on login if user does not exist.</p>
<p>For now I'll tidy up the endpoint request code to use an authorization header rather than adding URL params.</p>
<pre><code class="language-rust">let mut email_res_headers = HeaderMap::new();

email_res_headers.insert(
    AUTHORIZATION,
    HeaderValue::from_str(
        &amp;(&quot;Bearer &quot;.to_string()
            + token_response.as_ref().unwrap().access_token().secret()),
    )
    .unwrap(),
);

// Access email address endpoint
let email_res = http_client(HttpRequest {
    body: vec![],
    headers: email_res_headers,
    method: Method::GET,
    url: Url::parse(&quot;https://openidconnect.googleapis.com/v1/userinfo&quot;).unwrap(),
});
</code></pre>
<blockquote>
<p>I think I need to work on Rust string concatenation, that doesn't look quite right.</p>
</blockquote>
<p>After poking the API for hours I've managed to convert my OAuth login to a Firebase account login.</p>
<blockquote>
<p><img src="/blog/img/dodgeball/nocompile.png" alt="">
This wouldn't compile with liquid, I don't know enough about eleventy to reason why yet. So here's a screenshot.</p>
</blockquote>
<p>After running this after getting the initial OAuth token and checking my firebase authentication dashboard...</p>
<blockquote>
<p><img src="/blog/img/dodgeball/login.png" alt="login.png">
Success!</p>
</blockquote>
<p>Just a bit more token juggling to go and I should be able to move on. Next target is testing <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a>.</p>
<p>I'll set some data on firestore, and try reading it from the Rust app.</p>
<blockquote>
<p><img src="/blog/img/dodgeball/firestore_data.png" alt="firestore_data.png">
Very original naming conventions here</p>
</blockquote>
<pre><code class="language-rust">let url = Url::parse(&quot;https://firestore.googleapis.com/v1/projects/test-auth-rs/databases/(default)/documents/test_collection/test_document&quot;).unwrap();

let mut headers = HeaderMap::new();

headers.insert(
    AUTHORIZATION,
    HeaderValue::from_str(format!(&quot;Bearer {}&quot;, token.as_str().unwrap()).as_str())
        .unwrap(),
);

let res = http_client(HttpRequest {
    url,
    method: Method::GET,
    headers,
    body: vec![],
});

let json = match str::from_utf8(res.unwrap().body.as_ref()) {
    Ok(v) =&gt; serde_json::from_str::&lt;serde_json::Value&gt;(v).unwrap(),
    Err(e) =&gt; panic!(&quot;Invalid UTF-8. {:?}&quot;, e),
};

let fields = match json.get(&quot;fields&quot;) {
    Some(e) =&gt; e,
    None =&gt; &amp;Value::Null,
};

let field = match fields.get(&quot;test_field&quot;) {
    Some(e) =&gt; e,
    None =&gt; &amp;Value::Null,
};

let value = match field.get(&quot;stringValue&quot;) {
    Some(e) =&gt; e,
    None =&gt; &amp;Value::Null,
};

println!(&quot;Document: {:?}\n&quot;, json);

println!(&quot;Value: {:?}\n&quot;, value);
</code></pre>
<blockquote>
<p><img src="/blog/img/dodgeball/firestore_get.png" alt="firestore_get.png">
Data retrieved!</p>
</blockquote>
<p>This bit of code uses the Firebase IdToken to retrieve data from firestore, according to the firestore rules (non-authed requests error out correctly). I need to do some research into how to effectively navigate nested JSON in Rust, or maybe just write some helper functions. I haven't even looked at learning macros yet, maybe they'll help? I'll cross that bridge when I come to it.</p>
<p>Good enough for the day. Next update for this project should bring the rest of CRUD, JSON parsing, and a refactor to prepare the firestore interface for use in Bevy.</p>
<p>Next up: get this blog online.</p>

</div>


<nav>
    <ol class='post-paginate'>
        <li>
            Previous:
            
                <a href="/blog/dodgeball-0/">dodgeball returns</a>
            
        </li>
        <li>
            Next:
            
                <a href="/blog/site-update-0/">website refresh</a>
            
        </li>
    </ol>
</nav>
        </div>
    </body>
</html>