<!DOCTYPE html>
<html lang="en" data-theme="light">
    <script>
        document.querySelector("html").setAttribute("data-theme", localStorage.getItem("theme") || "light");
    </script>
    <head>
        <link
        rel="stylesheet" href="/assets/css/styles.css"> <!-- eleventy-plugin-metagen --><meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Bevy + Firebase - bytemunch.dev</title>
	<meta name="author" content="Sam Edelsten">
	<meta name="title" content="Bevy + Firebase - bytemunch.dev">
	<meta name="description" content="creating a bevy plugin for firebase">
	<meta name="generator" content="eleventy">
	<!-- Open Graph -->
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://bytemunch.dev/blog/bevy-firebase-0/">
	<meta property="og:locale" content="en_US">
	<meta property="og:title" content="Bevy + Firebase - bytemunch.dev">
	<meta property="og:description" content="creating a bevy plugin for firebase">
	<meta property="og:image" content="/projects/bevy-firebase/img/thumb.png">
	<meta property="og:image:alt" content="badly hand drawn firebase logo next to a firebase-coloured badly drawn bevy logo on a white circle">
	<!-- Twitter -->
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:site" content="@bytemunch">
	<meta name="twitter:creator" content="@bytemunch">
	<meta name="twitter:url" content="https://bytemunch.dev/blog/bevy-firebase-0/">
	<meta name="twitter:title" content="Bevy + Firebase - bytemunch.dev">
	<meta name="twitter:description" content="creating a bevy plugin for firebase">
	<meta name="twitter:image" content="/projects/bevy-firebase/img/thumb.png">
	<meta name="twitter:image:alt" content="badly hand drawn firebase logo next to a firebase-coloured badly drawn bevy logo on a white circle">
	<link rel="canonical" href="https://bytemunch.dev/blog/bevy-firebase-0/">
    </head>
    <body>
        <div id="main">
            <div class="title">
                <h1>
                    <a href="/">bytemunch<span class="title-secondary">dot</span>dev</a><a href="/blog" class="title-location">
                            <span class="title-secondary">slash</span>blog</a></h1>
                <p
                    id="theme-switch"
                    href="javascript:void(0)"
                    onclick=" let theme = localStorage.getItem('theme') || 'light'; document.querySelector('#theme-switch').textContent =
                        theme; theme = theme == 'light' ? 'dark' : 'light'; localStorage.setItem('theme',theme);
                        document.querySelector('html').setAttribute('data-theme',theme); ">
                    theme toggle</p>
                <script>
                    let theme = localStorage.getItem('theme') || 'light';
                    document.querySelector('#theme-switch').textContent = theme == 'light'
                        ? 'dark'
                        : 'light';
                </script>
            </div>
            


<nav>
    <ol class='post-paginate'>
        <li>
            Previous:
            
                <a href="/blog/dodgeball-4/">Firestore rules</a>
            
        </li>
        <li>
            Next:
            
                <a href="/blog/msse-0/">Movie Snacks!</a>
            
        </li>
    </ol>
</nav>
<div id="post-header">
    <h1>Bevy + Firebase</h1>
    <p>creating a bevy plugin for firebase</p>
    <p class="date">14/06/2023</p>
</div>
<div id="post">
    <h2>That's ambitious</h2>
<p>Yeah we're getting into the weeds a bit with this one.</p>
<h2>The Goal</h2>
<p>By the end of this blog post I hope to have a couple things done: Firebase Auth in Bevy, and User-Facing Firestore access from within a Bevy app. It won't be pretty, but I hope to make it work for my purposes.</p>
<h2>Starting off</h2>
<p>First of all I'll refactor my testing code into something more respectable, slimming down dependencies and the like. Then I'll need to move all the functions I have currently working for the oAuth2 flow into a portable crate.</p>
<p>The crate will also provide the required login URL and handle the response. The crate will keep a reference to the idToken, and refresh it when needed or asked.</p>
<p><sub>uh wait how do i make a crate?</sub></p>
<h2>Slimming down</h2>
<p>After learning how to make my own library crate, I'll next need to write the Bevy plugin. I'll create a resource for each of the required keys, set with the plugin's struct.</p>
<pre><code class="language-rs">pub struct BevyFirebasePlugin {
  pub firebase_api_key: String,
  pub google_client_id: String,
  pub google_client_secret: String,
  pub firebase_refresh_token: Option&lt;String&gt;,
}
</code></pre>
<p>My asynchronous code doesn't work with Bevy. After a little searching I've come across <a href="https://crates.io/pecs">pecs</a>, which allows Promise like behaviour. Pecs also comes with it's own HTTP client, so instead of having double dependencies I'll look into completing the whole auth process with just pecs.</p>
<p>Easiest to port is perhaps the token refreshing function.</p>
<pre><code class="language-rs">fn refresh_login(
  mut commands: Commands,
  refresh_token: Res&lt;BevyFirebaseRefreshToken&gt;,
  firebase_api_key: Res&lt;BevyFirebaseApiKey&gt;,
) {
  let tokens = (refresh_token.0.clone().unwrap(), firebase_api_key.0.clone());

  commands.add(
    Promise::new(tokens, asyn!(state=&gt;{
      asyn::http::post(format!(&quot;https://securetoken.googleapis.com/v1/token?key={}&quot;,state.1))
      .header(&quot;content-type&quot;, &quot;application/x-www-form-urlencoded&quot;)
      .body(format!(&quot;grant_type=refresh_token&amp;refresh_token={}&quot;,state.0))
      .send()
    }))
    .then(asyn!(_state, result, mut commands:Commands=&gt;{
      let json = serde_json::from_str::&lt;serde_json::Value&gt;(result.unwrap().text().unwrap()).unwrap();

      let id_token = json.get(&quot;id_token&quot;).unwrap().as_str().unwrap();

      commands.insert_resource(BevyFirebaseIdToken(id_token.into()));
    }))
  );
}
</code></pre>
<p>I'm liking working with pecs, the control flow makes sense and the builder pattern for creating HTTP requests is easy to understand.</p>
<h2>Full login flow</h2>
<p>Refreshing a token works! If the plugin is given a refresh token, it inserts an ID token resource to Bevy's ECS world.</p>
<p>Unfortunately logging in without a refresh key is bugged <em>somewhere</em> and I've got 150 lines of basically untested code to debug. Fab.</p>
<p>Okay I've got the full login flow up and running! Problem is, the listening server is blocking execution, so I need to find a non-blocking solution to embed in promises, so that the app can still function while waiting for login, at least enough to display some &quot;Waiting for browser login...&quot; graphic and a cancel button.</p>
<p>After hours of trying, I found a working solution! It runs at 1fps! Playable!
I was polling <code>TcpListener::accept</code> every frame, and with no graphics it looked like it was working fine... Unfortunately I noticed it was running slow when I tried logging from a Bevy system and I could read my console.</p>
<p>Back to the drawing board.</p>
<h2>ay nice threads</h2>
<p>Time to learn how Rust + Bevy does async. I'm hoping to spawn an async task that runs the <code>TcpListener::accept</code> server, and sends an event when it gets an auth code. So I gotta learn <a href="https://docs.rs/crossbeam/latest/crossbeam/">crossbeam</a> and how <a href="https://docs.rs/bevy/latest/bevy/tasks/index.html">tasks</a> work in bevy now.</p>
<p>I'm seeing a lot of <code>move</code> in the examples too, I should probably try to understand how it interacts with closures too.</p>
<p>After implementing threads, it seems I might be able to do without crossbeam. I've got the task running separately, I just need to grab the data out of the other side. I think I'll need to move the server task into a component rather than a resource? Then I'll be able to take ownership, cancel the <code>Future</code>, and extract the auth code?</p>
<blockquote>
<pre><code class="language-rs">let auth_code = future::block_on(future::poll_once(&amp;mut task.0));
</code></pre>
<p>or something like that</p>
</blockquote>
<p>That worked a treat. Once I got full auth flow working, I started ripping out dependencies. Apparently I don't need a whole crate with a special struct for everything in oAuth2, I can just send POST requests with plaintext bodies using pecs' built-in http client. That's a load of boilerplate gone. I don't know enough about PKCE, but I'm not sure I need to be protected against cross site request forgery (which I understand as stealing and reusing a refresh token). I'll put it on the back-burner for now and add it for tighter security later.</p>
<p>With all that guff deleted, I'm back to under 100 lines of working code. Nice.</p>
<p>Next up, I'll write some wrappers to interface with Firestore from within Bevy. I'm hoping to implement transactions that can be sent with configurable time intervals, and some sort of safety to prevent trying to hit Firestore every frame. I'm thinking Listeners will need to utilise my newfound task knowledge too.</p>

</div>


<nav>
    <ol class='post-paginate'>
        <li>
            Previous:
            
                <a href="/blog/dodgeball-4/">Firestore rules</a>
            
        </li>
        <li>
            Next:
            
                <a href="/blog/msse-0/">Movie Snacks!</a>
            
        </li>
    </ol>
</nav>
        </div>
    </body>
</html>